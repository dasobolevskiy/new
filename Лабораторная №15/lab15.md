# **РОССИЙСКИЙ УНИВЕРСИТЕТ ДРУЖБЫ НАРОДОВ**

## **Факультет физико-математических и естественных наук**

## **Кафедра прикладной информатики и теории вероятностей**

# **ОТЧЕТ ПО ЛАБОРАТОРНОЙ РАБОТЕ № 15**

*дисциплина: операционные системы*

Студент: Соболевский Денис Андреевич

Группа: НФИбд-02-20

**МОСКВА**

2021 г.

### Цель работы:

Приобретение практических навыков работы с именованными каналами.


### Теоретическое введение:

Одним из видов взаимодействия между процессами в операционных системах является обмен сообщениями. Под сообщением понимается последовательность байтов, передаваемая от одного процесса другому.

В операционных системах типа UNIX есть *3 вида межпроцессорных взаимодействий*: 

- общеюниксные (именованные каналы, сигналы);

- System V Interface
Definition (SVID — разделяемая память, очередь сообщений, семафоры)

- BSD (сокеты).

Для передачи данных между неродственными процессами можно использовать
механизм именованных каналов (named pipes). Данные передаются по принципу
***FIFO*** (First In First Out) (первым записан — первым прочитан), поэтому они называются также FIFO pipes или просто FIFO. Именованные каналы отличаются от
неименованных наличием идентификатора канала, который представлен как специальный файл (соответственно имя именованного канала — это имя файла). Поскольку файл находится на локальной файловой системе, данное IPC используется
внутри одной системы.

Файлы именованных каналов создаются функцией ```mkfifo(3)```.

```
#include <sys/types.h>
#include <sys/stat.h>
int mkfifo(const char *pathname, mode_t mode);
```

Первый параметр — имя файла, идентифицирующего канал, второй параметр —
маска прав доступа к файлу.

Вызов функции mkfifo() создаёт файл канала (с именем, заданным макросом
FIFO_NAME):

```
mkfifo(FIFO_NAME, 0600)
```

Подробнее с данным типом каталов можно ознакомиться в статье *"Каналы FIFO"*[[1]]().

### Задание:

*Изучите приведённые в тексте программы server.c и client.c. Взяв данные
примеры за образец, напишите аналогичные программы, внеся следующие изменения:*

1. *Работает не 1 клиент, а несколько (например, два).*


2. *Клиенты передают текущее время с некоторой периодичностью (например, раз
в пять секунд). Используйте функцию sleep() для приостановки работы клиента.*


3. *Сервер работает не бесконечно, а прекращает работу через некоторое время (например, 30 сек). Используйте функцию clock() для определения времени работы
сервера. Что будет в случае, если сервер завершит работу, не закрыв канал?*

---

### Выполнение работы:

**Задание 1**

1. Создадим предложенные в лабораторной работе файлы с кодами при помощи текстового редактора ```emacs```. Таким образом, создаем файлы ```common.h``` (*рисунок 2*), ```server.c```(*рисунок 3*), ```client.c```(*рисунок 4*) и ```Makefile```(*рисунок 5*) с внесенными в них кореективами, как того от нам требуют задания.


*Рисунок 1:*

![](https://sun9-61.userapi.com/impg/Rmt-xFIk9BZnttgaeFJaPxzAWHGEdy_0vO4U4g/yZr7NRjYQII.jpg?size=425x153&quality=96&sign=02fc93bd37e4b44907e4639f2a9e59f3&type=album)

*Рисунок 2:*

![](https://sun9-17.userapi.com/impg/a0iMc4DNdG8TlIZs77_bo1CFJPaz6MkRro0nXg/ofmRjhyD1XA.jpg?size=498x292&quality=96&sign=1eddcd34c7ed1a6fbe851c52f32d81c9&type=album)

*Рисунок 3:*

![](https://sun9-13.userapi.com/impg/XRA_Dfyz8bN1qkkMZfDei7qkBeZZvz3JjAGFpQ/PlWuBZF6cvs.jpg?size=530x301&quality=96&sign=35b8d75fe69200d9ee2e5bf1b2c94d11&type=album)

*Рисунок 4:*

![](https://sun9-32.userapi.com/impg/2CyCyECawr3FNVIYIlOi39rlf1ecruIGARhLCQ/q7EL_ZBCs48.jpg?size=619x282&quality=96&sign=d7801f97e5b1ec891d8c18e8a1161c3d&type=album)

*Рисунок 5:*

![](https://sun9-21.userapi.com/impg/fgHUVlqUwjm8uZP7MVJMoV_kkZj_ja9kaGjEVA/cGdoKnMmHUc.jpg?size=608x280&quality=96&sign=d550d926f0fde6b4b21a69fd22c5f474&type=album)

Какие коррективы были внесены в первоначальный код:

- в файле server.c появилась функция clock(), помогающая подсчитывать кол-во времени, затраченное на выполнение алгоритма, подробнее с данной функцией можно ознакомиться статье *Измерение времени выполнения блока кода на C/С++*[[2]]();

- в файле client.c вывод текущей даты и времени осуществляем 5 раз с интервалом в 5 секунд - ```sleep(5)```; 

Далее компилируем наши программы server.c и client.c при помощи компилятора ```gcc``` (*рисунок 1*). Система не выдает нам ошибок, следовательно все реализовано верно.

2. Проверяем работу программ. Откроем три терминала, в одном из них первую очередь запускаем ```server.c```, а в оставшихся двух - два ```./client.c```. 

Видим, что оба клиента выводят дату и время, можно заметить что каждый из них делает это с интервалов в 5 секунд, а интервалы межды выводами раздых клиентов равно разнице во времени из запуска, в нашем случае - 3 секунды. Отсюда и итоговое время выполнения работы: 0.33 sec.

### Вывод:

Приобрел практические навыки работы с именованными каналами.

### Библиография:

[1]: [Каналы FIFO](https://it.wikireading.ru/34266)

[2]: [Измерение времени выполнения блока кода на C/С++](http://dkhramov.dp.ua/Comp.TimeCount#.YL9LmfkzZPY)








