# **РОCСИЙСКИЙ УНИВЕРСИТЕТ ДРУЖБЫ НАРОДОВ**
## Факультет физико-математических и естественных наук 
## Кафедра прикладной информатики и теории вероятностей 

## ОТЧЕТ
## ПО ЛАБОРАТОРНОЙ РАБОТЕ № 14

### *дисциплина: Операционные системы*

Студент: Соболевский Денис Андреевич 

Группа: НФИбд-02-20

Преподаватель: Велиева Татьяна Рефатовна

МОСКВА 

2021 г.

---

### **Цель работы:**

Приобрести простейшие навыки разработки, анализа, тестирования и отладки
приложений в ОС типа UNIX/Linux на примере создания на языке программирования С калькулятора с простейшими функциями.

### **Задачи:**

1. Научиться выполнять компиляцию по средствам командной строки;
2. Освоить отладчик GDB;
3. Научиться анализировать исходные коды.

### **Теоретическое введение:**

***Этапы разработки приложений***

- планирование, включающее сбор и анализ требований к функционалу и другим
характеристикам разрабатываемого приложения;

- проектирование, включающее в себя разработку базовых алгоритмов и спецификаций, определение языка программирования;

- непосредственная разработка приложения:
    - кодирование — по сути создание исходного текста программы (возможно в
нескольких вариантах);
    - анализ разработанного кода;
    - сборка, компиляция и разработка исполняемого модуля;
    - тестирование и отладка, сохранение произведённых изменений;

- документирование.

***Компиляция исходного текста и построение исполняемого
файла***

Для компиляции, например, файла ```main.c``` используют команду:

```
gcc -c main.c
```

Если требуется получить исполняемый файл с определённым именем (например, hello), то требуется воспользоваться опцией -o и в качестве параметра задать
имя создаваемого файла:

```
gcc -o hello main.c
```

С прочими опциями компилятора ```gcc``` можно ознакомиться в статье *"Опции компиляторов"*[[1]]().

Для сборки разрабатываемого приложения и собственно компиляции полезно
воспользоваться утилитой ```make```. Она позволяет автоматизировать процесс преобразования файлов программы из одной формы в другую, отслеживает взаимосвязи
между файлами.

***Тестирование и отладка***

Для использования отладчика GDB необходимо скомпилировать анализируемый код программы таким образом, чтобы отладочная информация содержалась в результирующем бинарном файле. Для этого следует воспользоваться опцией -g компилятора
gcc:

```
gcc -c file.c -g
```

После этого для начала работы с gdb необходимо в командной строке ввести одноимённую команду, указав в качестве аргумента анализируемый бинарный файл:

```
gdb file.o
```

Затем можно использовать по мере необходимости различные команды gdb.

***Анализ исходного текста программы***

Для анализа кода программы example.c следует выполнить следующую команду:

```
splint example.c
```

***В ходе работы*** над понадобится установить утилиту splint на Centos 7, поэтому воспользуемся статьей *"УСТАНОВКА ПАКЕТОВ В CENTOS 7"*[[2]]().

Все коды, которые использовадись во время выполнения работы были взяты из *Лабораторной работы №14*[[3]]().

### Выполнение работы:

1, 2. В домашнем каталоге нам нужно создать подкаталог ~/work/os/lab_prog.

Создаем каталог os в уже созданном ранее каталоге work и создаем в нем подкаталог lab_prog - ```mkdir lab_prog``` (*рисунок 1*). Перейдем в него командой cd lab_prog. Создадим в нём файлы: calculate.h, calculate.c, main.c с помощью текстового редактора ```emacs``` (*рисунок 1*).
Это будет примитивнейший калькулятор.

![](https://sun9-31.userapi.com/impg/Kco9kRqYEFcBJlD7puV_PC4si4ZDcuG5Pp08ww/PKC01Lo6dV0.jpg?size=438x65&quality=96&sign=07846aa98d3b1f88f60620316df061ee&type=album)

    рисунок 1: создание подкаталога ~/work/os/lab_prog и файлов calculate.h, calculate.c, main.c 

В файл calculate.h вводим код на языке программирования С, предоставленный в материалах к ЛР №14 (*рсиунок 2*)

![](https://sun9-3.userapi.com/impg/vj9SHiQoWzjy3Td5XarCwgk9tNrs5pdOUGzMsA/-fBNr4GLLmU.jpg?size=488x227&quality=96&sign=a3f705bdfe56ec587ff7f8bbe7bcd04f&type=album)

    рисунок 2: файл calculate.h

То же делаем с файлами calculate.c (*рисунок 3*) и main.c (*рисунок 4*).

![](https://sun9-67.userapi.com/impg/ozgi7tCmTe0FyuOeBhX89HsEYuo-VHk39FZjXA/5iIrGCBhE1E.jpg?size=593x296&quality=96&sign=3c67f3607c7a44d10271db6352ce5803&type=album)

    рисунок 3: файл calculate.c

![](https://sun9-48.userapi.com/impg/1vGxZCp16Mne6UXCHuCHi9jWjTk33WHvpjfiEg/mMGB82KT6MY.jpg?size=455x314&quality=96&sign=8bdb6f2afa2006e0ff6d9af0446802d8&type=album)

    рисунок 4: файл main.c

3, 4. Теперь выполним компиляцию программы посредством gcc, ввода следующие команды (*рисунок 5*):

```
gcc -c calculate.c
gcc -c main.c
gcc calculate.o main.o -o calcul -lm
```

![](https://sun9-34.userapi.com/impg/IWNyhxOHNIIwwyZ9SAMEG4xLcjY_7zPpuHf_8Q/2m7tQKci5Mo.jpg?size=585x69&quality=96&sign=eed145c31d20614d0c8526c88f1d6d45&type=album)

    рисунок 5: компиляция прогарммы посредством gcc

Видим, что система не выдает нам сообщений об ошибках, следовательно код написан правильно, и нам нечего исправлять.

5. Создадим Makefile, который будет расположен в каталоге lab_prog, поскольку makefile должен находиться в том же месте, где и проект, связанный с ним. Создаем файл с помощью редактора emacs и вводим в него предложенный код файла из лабораторной работы (*рисунок 6*).

![](https://sun9-48.userapi.com/impg/eXGJcppKV8VL0JdLUupzwtpLn483blSuiYm6JQ/-tsKikfdxnc.jpg?size=623x335&quality=96&sign=597903cb36ba2686407f5ddaddf7a704&type=album)

    рисунок 6: создание Makefile

6. С помощью gdb выполним отладку программы calcul. Для использования GDB нам необходимо сначала скомпилировать анализируемый код программы таким образом, чтобы отладочная информация содержалась в результирующем бинарном файле (*рисунок 7*). Для этого следует воспользоваться опцией -g компилятора
gcc, тогда синтаксис компиляции будет следующим:

```
gcc -c [имя файла] -g
```

![](https://sun9-12.userapi.com/impg/9IB9xDbRdDb3bKxeBN7ZhIhfUoJu753ce0GD2w/qSDDeupVZIw.jpg?size=581x65&quality=96&sign=df17e3a81a692dedc832c963d219da6f&type=album)

    рисунок 7: компиляция перед запуском GDB

- Запустим отладчик GDB, загрузив в него программу для отладки:
```gdb ./calcul``` (*рисунко 8*).

![](https://sun9-40.userapi.com/impg/rhw8Z2wgLsp0FivwS-lrv4rFkW3huL54KRykkQ/NJRl8jRACks.jpg?size=585x182&quality=96&sign=0c2baaab6d122a422d9fa2276e39ab7c&type=album)

    рисунок 8: запуск отладчика GDB

- Теперь нам нужно запустить программу внутри отладчика. Для этого внутри отладчика введем команду ```run```` (*рисунок 9*).

![](https://sun9-22.userapi.com/impg/v76YKShxIFzSWi1viAKs2kwStDt-BNct454lCQ/Ty1rHNtTCZk.jpg?size=583x137&quality=96&sign=6b70b0df428272379a75572c8e389257&type=album)

    рисунок 9: запуск программы в отладчике

Видим, что программа была успешно запущенна. На ввод нам предлагается ввести какое-либо число (вводим 4), операцию, которая будет производится с ним (в нашем случае это сложение), далее нам предлагается ввести второе слагаемое (5). Результат выделен черным - 9. Программа работает исправно.

- Для постраничного (по 9 строк) просмотра исходного код используем команду ```list``` (*рисунок 10*). Видим, что действительно вывелось 9 строк (4-13).

![](https://sun9-29.userapi.com/impg/HtIrq8K6ex4Jn1Ln6LVzBAXAfodKrCuQ6F2lgw/hIREdksCefY.jpg?size=256x172&quality=96&sign=99f5200983bf0a5b9150bd9f0bd1eaad&type=album)

    рисунок 10: постраничный вывод list

- Для просмотра строк с 12 по 15 основного файла используем list с параметрами - ```list 12,15``` (*риснуок 11*).

![](https://sun9-29.userapi.com/impg/lwiPqZIiRw6xAT5lpaRzUjQqYVTH0_07or71kw/8RGucgA7bOM.jpg?size=458x90&quality=96&sign=49fdacfd5465e20523a953aae3ce4394&type=album)

    рисунок 11: просмотр определенных строк

- Для просмотра определённых строк не основного файла используем list с параметрами: ```list calculate.c:20,29``` (*рисунок 12*).

![](https://sun9-17.userapi.com/impg/EX3THdYy3vRMVskSyi2JYFv0NG4mWSH9fqIJCA/8aet6m_xLmE.jpg?size=371x188&quality=96&sign=bdb72cd943c9647ec52725a932d90e29&type=album)

    рисунок 12: просмотр определённых строк не основного файла

- Установим точку останова в файле calculate.c на строке номер 21: ```break 21``` (*рисунок 13*).

![](https://sun9-44.userapi.com/impg/yEkoB18vmDdrlRKicK4TJvOqf0XkpgCxL7gl0A/P_o1jjTxh5s.jpg?size=420x39&quality=96&sign=b5484e2b074a725cb664554876fda476&type=album)

    рисунок 13: установка точки останова

Видим, что точка была успешно установлена.

- Выведем информацию об имеющихся в проекте точка останова. Для этого введем команду ```info breakpoints``` (*рисунок 14*).

![](https://sun9-11.userapi.com/impg/40xstE5Sm7eExT2ko4XCvA3vZdL0Mhp-EEgfcQ/aHfSEqwveQw.jpg?size=529x84&quality=96&sign=0fe0052627bdb1503a23d022be1432cd&type=album)

    рисунок 14: информация об имеющихся в проекте точка останова

Можем наблюдать информацию о точке, которую мы только что установили: ее номер, тип, адрес, место установки. 


- Убираем точки останова. Сначала посмотрим информацию о текущих точках ```info breakpoints```, чтобы узнать номер точки, которую мы собираемся удалить. Далее удаляем ее ```delete 1```, где 1 - номер точки. Снова просматриваем ```info breakpoints```, чтобы убедиться в удлении точки (*рисунок 15*).

![](https://sun9-32.userapi.com/impg/Ymo3YxY0WoRbo_UNGOVCItROB_aMSh0Ffyrduw/J10VSgCXYNk.jpg?size=543x126&quality=96&sign=6748f558bc3686be14f9fde72cdf6283&type=album)

    рисунок 15: удаление точки останова

Видим по последнему выводу, что точка была успешно удалена.

1. Теперь с помощью утилиты splint нам нужно проанализировать коды файлов calculate.c и main.c. Для этого сначала установим данную утилиту. (*рисунок 16*). 

![](https://sun9-36.userapi.com/impg/bpofHuHxWVAVpnh-JnVMDeIb0TXDDXbi53RbhQ/8GfjF7Vo6W4.jpg?size=455x137&quality=96&sign=5a17b00d8697ce8f2ca019d4506a4b66&type=album)

    рисунок 16: установка утилиты splint



Анализируем коды файлов calculate.c (*рисунок 17*) и main.c (*рисунок 18*) через ```splint [имя файла]```.

![](https://sun9-50.userapi.com/impg/KZPsSVTf3GlNoS7442zLRrVgNVdhBi1Sq351Bg/E9GZ4pzueao.jpg?size=593x399&quality=96&sign=2b3b099b10d9f8b9b62056c90feb860a&type=album)

    рисунок 17: анализ кода calculate.c

![](https://sun9-50.userapi.com/impg/klkaSJy9LpH28cB4oQROkEJMiOCIzhCW3UZClA/dEmeEpbxbQ0.jpg?size=609x317&quality=96&sign=bb240a2f31682c7967089004481ca0e4&type=album)

    рисунок 18: анализ кода main.c

Видим, что утилита ```splint``` анализирует программный код, проверяет корректность задания аргументов использованных в программе функций и типов
возвращаемых значений, а также обнаруживает синтаксические и семантические ошибки.

---

## Вывод: 

Приобрел простейшие навыки разработки, анализа, тестирования и отладки приложений в ОС типа UNIX/Linux на примере создания на языке программирования С калькулятора с простейшими функциями.

### Библиография:

[1]: [Опции компиляторов](https://parallel.uran.ru/book/export/html/15)

[2]: [УСТАНОВКА ПАКЕТОВ В CENTOS 7](https://losst.ru/ustanovka-paketov-v-centos-7)

[3]: [Лабораторная работа №14](https://esystem.rudn.ru/pluginfile.php/1142386/mod_resource/content/2/011-lab_prog.pdf)

---