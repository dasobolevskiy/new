# **РОССИЙСКИЙ УНИВЕРСИТЕТ ДРУЖБЫ НАРОДОВ**

## **Факультет физико-математических и естественных наук**

## **Кафедра прикладной информатики и теории вероятностей**

# **ОТЧЕТ ПО ЛАБОРАТОРНОЙ РАБОТЕ № 13**

*дисциплина: операционные системы*

Студент: Соболевский Денис Андреевич

Группа: НФИбд-02-20

**МОСКВА**

2021 г.

### Цель работы:

Изучить основы программирования в оболочке ОС UNIX. Научиться писать более сложные командные файлы с использованием логических управляющих конструкций и циклов.


### Теоретическое введение:

В данной лабораторной работе нам предстоит научиться писать командные файлы и использовать их на практике. Для этого нам необходимо ознакимиться с некоторой теорией.

**Командные процессоры (оболочки)**

Командный процессор (командная оболочка, интерпретатор команд shell) — это программа, позволяющая пользователю взаимодействовать с операционной системой компьютера.

В операционных системах типа UNIX/Linux наиболее часто используются следующие реализации командных оболочек:

•	оболочка Борна (Bourne shell или sh) — стандартная командная оболочка UNIX/Linux, содержащая базовый, но при этом полный набор функций;

•	С-оболочка (или csh) — надстройка на оболочкой Борна, использующая Сподобный синтаксис команд с возможностью сохранения истории выполнения команд;

•	оболочка Корна (или ksh) — напоминает оболочку С, но операторы управления программой совместимы с операторами оболочки Борна;

•	BASH — сокращение от Bourne Again Shell (опять оболочка Борна), в основе своей совмещает свойства оболочек С и Корна (разработка компании Free Software Foundation).

POSIX (Portable Operating System Interface for Computer Environments) — набор стандартов описания интерфейсов взаимодействия операционной системы и прикладных программ.

Стандарты POSIX разработаны комитетом IEEE (Institute of Electrical and Electronics Engineers) для обеспечения совместимости различных UNIX/Linuxподобных операционных систем и переносимости прикладных программ на уровне исходного кода. POSIX-совместимые оболочки разработаны на базе оболочки Корна. Рассмотрим основные элементы программирования в оболочке bash. В других оболочках большинство команд будет совпадать с описанными ниже.

**Переменные в языке программирования bash**

Командный процессор bash обеспечивает возможность использования переменных типа строка символов. Имена переменных могут быть выбраны пользователем. Пользователь имеет возможность присвоить переменной значение некоторой строки символов. Например, команда

mark=/usr/andy/bin

присваивает значение строки символов /usr/andy/bin переменной mark типа строка символов.

Использование:

mv afile ${mark}

переместит файл afile из текущего каталога в каталог с абсолютным полным именем /usr/andy/bin.

Использование значения, присвоенного некоторой переменной, называется подстановкой.

**Команды read и echo**

Команда read позволяет записать значение для переменной с клавиатуры. Она имеет следующий синтаксис:

read <variable>

Команда echo выводит текст на экран, если имеет вид:

echo "Some text"

В данном случае она выведет на экран Some text.

С помощью данной команды также можно вывести на экран содержимое, например, переменных:

echo <variable>

С прочей теорией и основами языка bash можно ознакомиться в материалах к лабораторной работе №11[1].

Также в ходе выполнения заданий лабораторной работы я столкнулся в необходимости изучения дополнительных натериалов, а именно:

• циклы if[2]

• массивы[3]

• утилита test[4]


### Выполнение работы:

**Задание 1**

Написать командный файл, реализующий упрощённый механизм семафоров. Командный файл должен в течение некоторого времени t1 дожидаться освобождения ресурса, выдавая об этом сообщение, а дождавшись его освобождения, использовать его в течение некоторого времени t2<>t1, также выдавая информацию о том, что ресурс используется соответствующим командным файлом (процессом). Запустить командный файл в одном виртуальном терминале в фоновом режиме, перенаправив его вывод в другой (> /dev/tty#, где # — номер терминала куда перенаправляется вывод), в котором также запущен этот файл, но не фоновом, а в привилегированном режиме.

Создадим командный файл lock.sh, который будет релаизовывать упрощенный механизм семафоров, с помощтю команды vi lock.sh, он сразу же откроется, начнем его написание (рисунок 1).

Задаем переменную lock, в которой хранится полный путь к файлу, который мы будем блокировать (даже если такого файла не существует, он будет создан по средствам последующих команд, выполняющихся в ком андном файле).

Далее присваиваем через команду exec {fn}>$lock дескриптор, для возможности работы с командой flock в дальнейшем.

Входим в бесконечный цикл while, условием которого является то, что lock является обычным файлом - test -f. В данном цикле имеется условие if, если файл уже заблокирован - flock -n ${fn} (где ${fn} дескриптор, номер нашего файла), - выводим сообщение об этом и выжидаем 4 секунды, имитируя внутреннюю рботу с файлом. После этого разблокируем файл и выводим сообщение об этом. Если же файл заблокировать не получается, тоже выводим об этом сообщение.


*Рисунок 1:*

![](https://sun9-69.userapi.com/impg/CprSlYEAF9tzcYOp4UejUxt7mujeE_p9G4wIcw/dsiAo-xUylo.jpg?size=602x410&quality=96&sign=0fff24b5c6033eb8d5f7a254194a1940&type=album)

Теперь проверим правильность работы нашего командного файла (риснуок 2). Для этого сначала добавим права на выполнение chmod +x lock.sh.

*Рисунок 2:*

![](https://sun9-10.userapi.com/impg/DGCSCUzRxdeGnfPS8lq3Z29fSwVnlztYi2Xm_g/QwBljNzM7Gs.jpg?size=393x38&quality=96&sign=f4b3466f1cc07099208254705f41d809&type=album)

Теперь откроем текстовую консоль tty2 нажатием клавиш Ctrl + Alt + F2. В ней вызовем наш командный файл и переадресуем вывод в третью текстовую консоль ./lock.sh > /dev/tty3 (риснуок 3).

*Рисунок 3:*

![](https://sun9-56.userapi.com/impg/gkb-8-WrxZjCKD60IO3qU0CIIJOVWWoF559wgA/4Rh2BAqp69w.jpg?size=371x50&quality=96&sign=ea8d8b29d7682ea23dc7c2a83d7cea3b&type=album)

Открываем консоль tty3 и видим, что в ней действительно выполняется командный файл - файл блокируется и разблокируется (рисунок 4).

*Рисунок 4:*

![](https://sun9-67.userapi.com/impg/VDqKZ3-VacmEI_7VSHM8Em3GAlTp4BHabtxy7Q/N8mo_0Wor6c.jpg?size=665x498&quality=96&sign=3b95c690a420877bbcce8ecbaae0b79d&type=album)

Запустим наш файл в консоли tty4 в фоновом режиме ./lock.sh &(рисунок 5).

*Рисунок 5:*

![](https://sun9-60.userapi.com/impg/3xaH0g9L2d9Ma8oLyQUItVZXYh9lV_b8fHzM9Q/c8z5Whsqa3g.jpg?size=660x313&quality=96&sign=89d8804448cba21ac648d301194b138d&type=album)

Таким образом мы наблюдаем, как запущенный файл в привилегированном режиме блокирует файл, работает с ним и разблокирует, а запущенный в фоновом режиме элементарно не успевает что-либо сделать с файлом, поскольку время его заплонированнной блокировки совпадает со временем, когда привилегировнный запуск работает с файлом.

**Задание 2**

Реализовать команду man с помощью командного файла. Изучите содержимое каталога /usr/share/man/man1. В нем находятся архивы текстовых файлов, содержащих справку по большинству установленных в системе программ и команд. Каждый архив можно открыть командой less сразу же просмотрев содержимое
справки. Командный файл должен получать в виде аргумента командной строки название команды и в виде результата выдавать справку об этой команде или сообщение об отсутствии справки, если соответствующего файла нет в каталоге man1.

Создадим командный файл man13.sh, который будет релаизовывать команду man, с помощтю команды vi man13.sh, он сразу же откроется, начнем его написание (рисунок 6).

2 строка - переходим в каталог /usr/share/man/man1. В нем находятся архивы текстовых файлов, содержащих справку по большинству установленных в системе программ и команд, которые мы будем просматривать. Зададим переменную command - имя команды, которое мы будем вводить с клавиатуры. Далее на экран командой echo выведем сообщение о том, что нам необходимо ввести имя команды, информацию о которой мы хотим узнать. Вводим ее с клавиатуры через read и снова выводим сообщение о том, что далее будет показана информация по данной команде (однако это ненужно, поскольку информация будет показана не в терминале, а в отдельном окне как привызове man). Командой less просмотрим содержимое справки, используя указатель на имя команды $.

*Рисунок 6:*

![](https://sun9-65.userapi.com/impg/EGYzlync8GHcUzpJy6ccJAY2_-9tt74u8lS4Ow/c0LR1Hvjo2U.jpg?size=414x165&quality=96&sign=ebabd87dcb3837a57eb9dfce4cfad5f1&type=album)

Теперь проверим правильность работы нашего командного файла (риснуок 7). Для этого сначала добавим права на выполнение chmod +x man13.sh. Далее вызовем наш файл для проверки в качестве команды ./man13.sh. Видим, что он выводит все сообщения так, как было задумано, после ввода команды (мы будем просматривать информацию о команде cp), действительно выводит справку о ней (рисунок 8). Нажимаем клавишу q, чтобы закончить просмотр справки.

*Рисунок 7:*

![](https://sun9-22.userapi.com/impg/u0CQDrFaHz6xelD2RQrUJrRzN9Py_BTs0UvwtA/FesfTsen2Bs.jpg?size=383x83&quality=96&sign=48dbdcf7dddb9b5f73ca41ec9dfbe15d&type=album)

*Рисунок 8:*

![](https://sun9-45.userapi.com/impg/OKwAdWeqvNuIW9BIHrxJk6LY7hmyQ8uxavUsHQ/XGKdWnhpKkI.jpg?size=612x420&quality=96&sign=04b4905ab6c5f5a4795fef79d142da3c&type=album)

**Задание 3**

Используя встроенную переменную $RANDOM, напишите командный файл, генерирующий случайную последовательность букв латинского алфавита. Учтите,
что $RANDOM выдаёт псевдослучайные числа в диапазоне от 0 до 32767.

Создадим командный файл random_line.sh, который будет релаизовывать генерацию строк с рандомным надором букв латинского алфавита, с помощью команды vi random_line.sh, он сразу же откроется, начнем его написание (рисунок 9).

*Рисунок 9:*

![](https://sun9-50.userapi.com/impg/0JGXO67YWtC1-GDWwQihMZ2xmn614m1LY4onvg/HbwLMWQ8RUk.jpg?size=426x139&quality=96&sign=0e2dde0d7dc44226a91dfbff9d0471c7&type=album)

Проверим работу нашего командного файла (рисунок 10). Для этого сначала добавим права на выполнение chmod +x random_line.sh. Далее вызовем наш файл для проверки в качестве команды ./random_line.sh. Повторим это несколько раз, видим, что на выход получаем строки разной длинны с произвольным набором букв - задача выполнена.

*Рисунок 10:*

![](https://sun9-18.userapi.com/impg/XreD7qcHKZ1dUOWiZKk2b3B0rx6vlfQoNolWRA/q_zjXSK_4NA.jpg?size=422x92&quality=96&sign=2e05459a9ca40d66e2f767a11c4c68b0&type=album)

### Вывод:

Изучил основы программирования в оболочке ОС UNIX. Научился писать более сложные командные файлы с использованием логических управляющих конструкций и циклов.

### Библиография:

[1] [Лабораторная работа №11](https://esystem.rudn.ru/pluginfile.php/1142377/mod_resource/content/2/008-lab_shell_prog_1.pdf)

[2] [Циклы if](https://habr.com/ru/company/ruvds/blog/325928/)

[3] [Использование массивов в bash](https://losst.ru/massivy-bash)

[4] [Утилита test](https://ru.wikipedia.org/wiki/Test)








